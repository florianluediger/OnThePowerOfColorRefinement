\section{Ergebnis und Laufzeit}
\label{sec/ergebnis}

%\begin{itemize}
%	\item Erklärung von Theorem 9
%	\item Vorstellung des Ergebnisses
%	\item Beweis der Laufzeit von $O((n+m)\log n)$
%\end{itemize}

Die vorgestellten lokalen und globalen Eigenschaften von CR-Graphen reichen wie im Folgenden gezeigt aus, um hinreichende Bedingungen für CR-Graphen zu formulieren und darauf basierend ein effizientes Verfahren für das Erkennen solcher Graphen zu entwickeln.

\subsection{Hinreichende Bedingungen für das Erkennen von CR-Graphen}
\begin{Theorem}
	Für einen Graphen $G$ sind folgende Aussagen äquivalent:
	
	\begin{enumerate}[label=(\alph*)]
		\item $G$ ist ein CR-Graph
		\item $G$ erfüllt Bedingungen \emph{A-F}
		\item $G$ erfüllt Bedingungen \emph{A}, \emph{B}, \emph{G} und \emph{H}
	\end{enumerate}
\end{Theorem}

\emph{Beweis:} Die Äquivalenz der Aussagen wird gezeigt, indem gezeigt wird, dass gilt: $(a)\rightarrow (b)\rightarrow (c)\rightarrow (a)$.
Die bisher erlangten Erkenntnisse ermöglichen es bereits einen großen Teil dieser Aussage zu bestätigen. Somit wurde in den Lemmata \ref{lemma:lokal} und \ref{lemma:global1} gezeigt, dass $(a)\rightarrow (b)$ gilt. Ebenfalls wurde in Lemma \ref{lemma:global2} gezeigt, dass $(b)\rightarrow (c)$ gilt. Es bleibt also nur noch zu zeigen, dass auch $(c)\rightarrow (a)$ gültig ist.

Sei dazu $G$ ein Graph, welcher die Bedingungen \emph{A}, \emph{B}, \emph{G} und \emph{H} erfüllt und $H$ ein durch Color Refinement nicht von $G$ unterscheidbarer Graph, dann ist zu zeigen, dass $G$ und $H$ isomorph sind.
Im Folgenden sei $C^s$, welche zur stabilen Partition $\mathcal{P}^s$ von der \glslink{disjunkte_vereinigung}{disjunkten Vereinigung} $G+H$ gehört.
Aus Gleichung \ref{eq:2} folgt, dass es eine Abbildung $f:\mathcal{P}_G\rightarrow \mathcal{P}_H$ gibt, welche die Zellen der stabilen Partition von $G$ auf die der stabilen Partition von $H$ so abbildet, dass diese die selbe Farbe und Kardinalität besitzen.

\begin{Lemma}
	Die Abbildung $f$ stellt einen Isomorphismus von $C(G)$ nach $C(H)$ dar, sofern für beliebige $X,Y\in G$ gilt:
	\begin{enumerate}[label=(\alph*)]
		\item $G[X]\simeq H[f(X)]$ und
		\item $G[X,Y]\simeq H[f(X),f(Y)]$
	\end{enumerate}
	\label{lemma:zell_isomorphismus}
\end{Lemma}

Beweis für Lemma \ref{lemma:zell_isomorphismus} (a):
Sowohl $X$ als auch $f(X)$ sind reguläre Graphen, da diese Zellen einer stabilen Partition sind.
Da beide Zellen durch die Konstruktion von $f$ die selbe Farbe besitzen und somit in der stabilen Partition $\mathcal{P}^s$ von $G+H$ in der selben Zelle liegen, haben die Graphen $G[X]$ und $H[f(X)]$ denselben Grad.
Aus dieser Eigenschaft und Bedingung \emph{A} folgt somit, dass $G[X]$ ein Unigraph ist, dessen Isomorphieeigenschaften durch seine Gradsequenzen vollständig definiert ist und daraus Behauptung (a) folgt.

Behauptung (b) folgt nach derselben Begründung aus Bedingung \emph{B}.\\

Da die in Lemma \ref{lemma:zell_isomorphismus} festgestellte Isomorphie zwischen den Zellgraphen $C(G)$ und $C(H)$ nicht ausreicht, um auf eine Isomorphie zwischen $G$ und $H$ zu schließen, wird im Folgenden der Isomorphismus $\phi $ aufgestellt.
Siehe dazu auch Kapitel [soundso], wo beschrieben wird, dass für den vorgestellten Graphen, welcher kein CR-Graph ist, die Bedingungen \emph{A} und \emph{B} dennoch erfüllt sind. %TODO Verweis einfügen
Lemma \ref{lemma:zell_isomorphismus} lässt darauf schließen, dass $\phi (X)=f(X)$ bereits ein gültiger Isomorphismus zum Abbilden der Subgraphen von Zellen aufeinander ist.

Die lokalen Eigenschaften von CR-Graphen helfen also dabei diesen Isomorphismus teilweise aufzustellen, dieser muss allerdings auch Zellübergreifend korrekt definiert sein, weshalb die globalen Eigenschaften ebenfalls benötigt werden.
Jede anisotrope Komponente $A$ des Zellgraphen $C(G)$ kann nach Bedingung \emph{H} maximal eine heterogene Zelle $R_A$ enthalten.
Sollte diese für eine Komponente nicht existieren, so sei $R_A$ eine beliebige Zelle minimaler Kardinalität in $A$.
Nach (a) kann $\phi$ für die Zelle $R_A$ jeder anisotroper Komponente ein beliebiger Isomorphismus von $G[R_A]$ nach $H[f(R_A)]$ sein.
Dieser Isomorphismus wird dann auf die anderen Zellen in $A$ übertragen, was im Folgenden genauer beschrieben wird.
Da $A$ nach Bedingung \emph{G} ein Baum ist, kann dieser von der Zelle $R_A$ gewurzelt werden, sodass der Baum $A_R$ entsteht.
Angenommen $\phi$ sei bereits für die Zelle $X$ definiert, so kann dieses über die Kante $G[X,Y]$ auf die Zelle übertragen werden, da nach der Monotonievoraussetzung von Bedingung \emph{G} und der Wahl von $R_A$ gilt, dass $|X|\leq |Y|$.
Für die Zelle $Y$ muss $\phi$ dann nur noch so gewählt werden, dass dieses einen Isomorphismus von $G[X,Y]$ nach $H[f(X),f(Y)]$ darstellt, was wegen (b) und der Tatsache, dass alle Knoten von $Y$ den Grad 1 im bipartiten Graphen $G[X,Y]$ oder dessen bipartiten Komplement hat, was ebenfalls für $f(Y)$ gilt, möglich ist.\\

Da $\phi$ durch seine Konstruktion ein Isomorphismus zwischen $G[X]$ und $H[f(X)]$ sowie zwischen $G[X,Y]$ und $H[f(X),f(Y)]$ ist, ergibt sich, dass $\phi$ ebenfalls ein Isomorphismus von $G$ zu $H$ ist.

\subsection{Laufzeit}
Zur Berechnung der Laufzeit wird im Folgenden davon ausgegangen, dass der Graph $G$ in Adjazenzlistendarstellung vorliegt.
Nach \cite{CARDON198285} lässt sich die stabile Partition eines Graphen $G$ in Zeit $\mathcal{O}((n+m)\log n)$ berechnen.

\begin{Theorem}
	Die Klasse der CR-Graphen ist in Zeit $\mathcal{O}((n+m)\log n)$ entscheidbar. Dabei bezeichnet $n$ die Anzahl der Knoten und $m$ die Anzahl der Kanten des Eingabegraphen.
\end{Theorem}

\emph{Beweis:} Zunächst wird die stabile Partition $\mathcal{P}_G=\{X_1,X_2,...,X_k\}$ berechnet, was wie eingangs erwähnt die Laufzeit $\mathcal{O}((n+m)\log n)$ benötigt.
Außerdem wird $C^*(G)$ definiert als der Zellgraph, bei dem sämtliche leeren Kanten, also solche bei denen keine Verbindungen zwischen den Elementen der beiden Endpunkte besteht, entfernt wurden.

Für die Elemente $X_i\in C^*(G)$ werden die Adjazenzlisten gebildet, indem die Adjazenzliste eines beliebigen Knoten $u\in X_i$ durchlaufen wird und sämtliche Zellen aufgelistet werden, welche einen zu $u$ adjazenten Knoten enthalten.
Die dadurch gewonnenen Informationen sind identisch für alle Knoten aus $X_i$, da diese alle gleichartige Nachbarschaften besitzen, weshalb es ausreicht die Operation für einen beliebigen Knoten durchzuführen.
Durch die Informationen aus der Adjazenzliste lässt sich der Grad der Knoten innerhalb der Zellen bestimmen und somit leicht Bedingung \emph{A} durch die in Lemma \ref{lemma:lokal_regulaer} vorgestellten Bedingungen für jeden Subgraphen $G[X_i]$ überprüfen.

Für jede Kante ${X_i,X_j}$ aus $C^*(G)$ wird der Wert $d_{ij}$ berechnet, welcher die Anzahl der Nachbarn in $X_j$ beschreibt, zu denen jeder Knoten aus $X_i$ adjazent ist.
Dieser Wert wird ebenfalls für den Fall $i=j$ betrachtet, wobei die Nachbarn innerhalb der Zelle gezählt werden.
Dadurch, dass die Werte $|X_i|$, $|X_j|$ und $d_{ij}$ nun bekannt sind, lässt sich Bedingung \emph{B} durch die in Lemma \ref{lemma:lokal_bipartit} vorgestellten Bedingungen überprüfen.

Da alle Zellen des Zellgraphen $C^*(G)$ im schlimmsten Falle unterschiedliche Farben haben, gibt es maximal $n$ Zellen.
Mit dem beschriebenen Verfahren können die Bedingungen \emph{A} und \emph{B} somit in der Zeit $\mathcal{O}(n)$ überprüft werden.

Zum Überprüfen von Bedingung \emph{H} wird eine Breitensuche auf dem Zellgraphen $C^*(G)$ durchgeführt, welche alle anisotropen Komponenten findet und gleichzeitig überprüft, ob diese eine Baumstruktur aufweisen und nur eine anisotrope Komponente enthält.

Wird diese Breitensuche nun von der Zelle minimaler Kardinalität für jede Komponente wiederholt, so lässt sich die in Bedingung \emph{G} beschriebene Monotonieeigenschaft für jede Kante überprüfen.

Der Breitensuchealgorithmus benötigt eine Laufzeit von $\mathcal{O}(n+m)$, da der Zellgraph maximal $n$ Knoten und maximal $m$ Kanten besitzt.

Es ist somit zu erkennen, dass das Errechnen der stabilen Partition, auf der die ganzen Operationen ausgeführt werden mit $\mathcal{O}((n+m)\log n)$ die dominierende Laufzeit des Algorithmus ist.